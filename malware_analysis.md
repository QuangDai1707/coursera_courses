# I. Introduction
## 1. Overview
### 1.1. Malware
- Definition: any software that can cause harm to user, computer or network
- Include:
    - Backdoor: install malicious code on computer and let attacker connect without authentication
    - botnet: same as backdoor, but all infected machines receive the same instruction for single cmd server
    - downloader: download and install other malicious code.
    - information-stealing malware: collect information from victim by sniffer, paswword hash grabber and keylogger
    - launcher: launcher other malicious program.
    - rootkit: hide the existence of other code.
    - scareware: frighten an infected user into buying something
    - spam-sending malware: send spam to infected machine
    - worm or virus: malicious code that can copy itself and infect additional machines
### 1.2. Malware analysis
- Malware analysis: study how malware work, how to identify, defeat or eliminate it
- The purpose: provide information needed for responding to a network intrusion.
- The goal: determine exactly what happened, and ensure to located all infected machines and files. When analyze suspected malware, determine exactly what a particular suspect binary can do, how to detect it on your network, and how to measure and contain its damage.
- Develop signature to detect malware infection on the network.
- Host-based signatures
    - detect malicious code on victim computers
    - include: identify files created or modified by malware or specific changes that it makes to the registry
- Network-based signatures
    - Detect malicious code by monitoring network traffic.
- final objective: figure out exactly how the malware works

### 1.3. General Rules for Malware Analysis
- don’t get too caught up in the details, Focus instead on the key features.
- different tools and approaches are available for different jobs. Try analyzing the malware from a different angle, or just try a different approach
- malware always develop, new malware analysis techniques are developed to catch up
# II. Malware Analysis Techniques
## 1. Basic Static Analysis
- examining the executable file without viewing the actual instructions.
1. Using antivirus tools to confirm maliciousness
    - good first step
    - rely on a database of file signature and behavioral and pattern-matching analysis (heuristics)
    - can be bypass by new malware with unknown signature.
2. Using hashes to identify malware
    - run malware through a hashing program (MD5, SHA1) that produces a unique hash
    - Use the hash as a label.
    - Share that hash with other analysts to help them to identify malware.
    - Search for that hash online to see if the file has already been identified.
3. Gleaning information from a file’s strings, functions, and headers
    - string: get hint about the functionality of program such access URL, function name
    - packed and obfuscated malware: packed original executable to make packed file’s strings, imports, and other information are compressed and invisible
4. Portable Executable File Format: 
    - file format is used by Windows executables, object code, and DLLs
    - contains the information necessary for the Windows OS loader to manage the wrapped executable code
    - PE files begin with a header that includes information about the code, the type of application, required library functions, and space requirements.
5. Linked Libraries and Functions
    - Code libraries: contain functionality common to many programs, connecte to the main executable by linking 
    - Static linking: all code from that library is copied into the executable, which makes the executable grow in size. 
    - Runtime linking: executable connect to libraries only when that function is needed, not at program start
    - Dynamic linking: the host OS searches for the necessary libraries when the program is loaded.
    - The PE file header stores information about every library that will be loaded and every function that will be used by the program and functions a file exports.
6. The PE File Headers and Sections
    - header: file metadata
    - section:
        - .text: contains the instructions that the CPU executes, the only section that can execute.
        - .rdata: contains read-only data that is globally accessible within the program
        - .idata: contains import function information
        - .edata: contains export function information
        - .data: contains the program’s global data, which is accessible from anywhere in the program
        - .rsrc: contains resource such img, icons, menu, strings
        - .pdata: contains exception-handling information
        - .reloc: contains information for relocation of library files
## 2. Basic Dynamic Analysis 
- running the malware and observing its behavior on the system in order to remove the infection, produce effective signatures, or both.
    - Registry By examining registry operations, you can tell how a piece of malware installs itself in the registry.
    - File system Exploring file system interaction can show all files that the malware creates or configuration files it uses.
    - Process activity Investigating process activity can tell you whether the malware spawned additional processes.
    - Network Identifying network connections can show you any ports on which the malware is listening.
## 3. Advanced Static Analysis
- reverse-engineering the malware’s internals to get program instructions
### 3.1. Levels of Abstraction:
- Hardware: physical level, consists of electrical circuits that implement complex combinations of logical operators (AND, OR, and NOT)
- Microcode: firmware, contains microinstructions that translate from the higher machine-code level to provide a way to interface with the hardware.
- Machine code: consists of opcodes, hexadecimal digits that tell the processor what you want it to do
- Low-level languages: a human-readable version of a computer architecture's instruction set.
- High-level languages: provide strong abstraction from the machine level and make it easy to use programming logic and flow-control mechanisms. These languages are typically turned into machine code by a compiler.
- Interpreted languages: top level, The code is translated into bytecode and executes within an interpreter, which is a program that translates bytecode into executablemachine code on the fly at runtime

### 3.2. Reverse-Engineering
- When malware is stored on a disk in binary form at the machine code level, use disassembler to generate assembly code.

### 3.3. The x86 Architecture
- follow Von Neumann architecture:
#### 3.3.1. The central processing unit (CPU)
    executes code, include:
- control unit (gets instructions to execute from RAM), 
- register (stores the address of the instruction to execute), 
- arithmetic logic unit (executes an instruction fetched from RAM and places the results in registers or memory)
#### 3.3.2. The main memory of the system (RAM) 
    stores all data and code, include sessions:
- Data: contains values that are put in place when a program is initially loaded, both static or global value
- Code: contains the instructions fetched by the CPU to execute the program’s tasks
- Heap: dynamic memory during program execution, create (allocate) new values and eliminate (free) values that the program no longer needs
- Stack: The stack is used for local variables and parameters for functions, and to help control program flow.
#### 3.3.3. An input/output system (I/O) 
interfaces with devices such as hard drives, keyboards, and monitors.

#### 3.3.4. Instructions
- building blocks of assembly programs, is made of a mnemonic and zero or more operands.

| Mnemonic | Destination operand | Source operand |
|----------|:-------------------:|---------------:|
| mov | ecx | 0x42 |

- 0x42000000 is treated as the value 0x42 because the x86 architecture uses the little-endian format.
- The endianness of data describes whether the most significant (big-endian) or least significant (little-endian) byte is ordered first (at the smallest address) within a larger data item
- Changing between endianness is something malware must do during network communication, because network data uses big-endian and an x86 program uses little-endian.
#### 3.3.5. Opcodes and Endianness
- Each instruction corresponds to opcodes (operation codes) that tell the CPU which operation the program wants to perform

| Instruction | mov ecx, | 0x42 |
|----------   |:--------:|-----:|
| Opcodes | B9 | 42 00 00 00 |

#### 3.3.6. Operands
- Identify the data used by an instruction, include:
    - Immediate operands are fixed values, such as the 0x42.
    - Register operands refer to registers, such as ecx.
    - Memory address operands refer to a memory address that contains the value of interest, typically denoted by a value, register, or equation
between brackets, such as [eax].

#### 3.3.7. Registers
- A register is a small amount of data storage available to the CPU, whose contents can be accessed more quickly than storage available elsewhere. Include:
    - General registers are used by the CPU during execution for storing data or memory addresses
    - Segment registers are used to track sections of memory.
    - Status flags: During execution, each flag is either set (1) or cleared (0) to control CPU operations or indicate the results of a CPU operation.
The following flags are most important to malware analysis:
        - ZF The zero flag is set when the result of an operation is equal to zero; otherwise, it is cleared.
        - CF The carry flag is set when the result of an operation is too large or too small for the destination operand; otherwise, it is cleared.
        - SF The sign flag is set when the result of an operation is negative or cleared when the result is positive. This flag is also set when the most significant bit is set after an arithmetic operation.
        - TF The trap flag is used for debugging. The x86 processor will execute only one instruction at a time if this flag is set.
    - Instruction pointers: contains the memory address of the next instruction to be executed for a program. 

| Instruction | Description 
|---------- |:-------------------:|
| mov eax, ebx | Copies the contents of EBX into the EAX register | 
| mov eax, 0x42 | Copies the value 0x42 into the EAX register | 
| mov eax, [0x4037C4] | Copies the 4 bytes at the memory location 0x4037C4 into the EAX register | 
| mov eax, [ebx] | Copies the 4 bytes at the memory location specified by the EBX register into the EAX register | 
| mov eax, [ebx+esi*4] | Copies the 4 bytes at the memory location specified by the result of the equation ebx+esi*4 into the EAX register | 

#### 3.3.8. Stack 
- The stack instructions include push, pop, call, leave, enter, and ret
- used for short-term storage only
- It frequently stores local variables, parameters, and the return address. Its primary usage is for the management of data exchanged between function calls.


## 4. Advanced Dynamic Analysis
- uses a debugger to examine the internal state of a running malicious executable.
# III. Malware functionality

# IV. 
# V. Anti Reverse Engineering
